#pragma once

#ifndef _INTERGEN_GENERATED__plugin_interface_LUA_H_
#define _INTERGEN_GENERATED__plugin_interface_LUA_H_

//@file Lua interface file for plugin_interface interface generated by intergen
//See LICENSE file for copyright and license information

#include "../plugin_interface.h"

#include <comm/intergen/ifc.lua.h>
#include <comm/token.h>

namespace lua {

class plugin_interface
{
public:

    ///Interface creator
    /// @param script - script for object to bind to
    /// @param bindvar - name of variable in script context for object to bind to
    /// @param ctx -
    static iref<::plugin_interface> get( lua_State* L__, const ::lua::script_handle& script__, const coid::token& bind_variable_name = coid::token(), const coid::token& script_class_name = coid::token(), iref<::lua::registry_handle>* ctx = 0)
    {
        typedef iref<::plugin_interface> (*fn_bind)(lua_State*, const ::lua::script_handle&, const coid::token&, const coid::token&, iref<::lua::registry_handle>*);
        static fn_bind binder = 0;
        static const coid::token ifckey = "plugin_interface.get@creator.lua";

        if (!binder)
            binder = reinterpret_cast<fn_bind>(coid::interface_register::get_interface_creator(ifckey));

        if (!binder)
            throw coid::exception("interface binder inaccessible: ") << ifckey;

        return binder(L__, script__, bind_variable_name, script_class_name, ctx);
    }
};

} //namespace lua


#endif //_INTERGEN_GENERATED__plugin_interface_LUA_H_
