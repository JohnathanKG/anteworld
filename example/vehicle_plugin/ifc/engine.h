#pragma once

#ifndef _INTERGEN_GENERATED__engine_H_
#define _INTERGEN_GENERATED__engine_H_

//@file Interface file for engine interface generated by intergen
//See LICENSE file for copyright and license information

//host class simplugin
//source file simplugin.hpp

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include <ot/vehicle_physics.h>

class simplugin;


namespace xt {

////////////////////////////////////////////////////////////////////////////////
class engine
    : public intergen_interface
{
public:

    // --- creators ---

    // --- interface methods ---
    ot::vehicle_params init_chassis(const coid::token& params);
    void init_vehicle(bool reload);
    void update_frame(float dt, float engine, float brake, float steering, float parking);
    void update_actions_script(float dt, const coid::range<int32>& actbuf);

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = 3500335767u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "xt::engine"_T;
        return _name;
    }

    int intergen_hash_id() const override { return HASHID; }

    bool iface_is_derived( int hash ) const override {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static(backend bck) {
        static constexpr coid::token _dc(""_T);
        static constexpr coid::token _djs("xt::engine@wrapper.js"_T);
        static constexpr coid::token _djsc("xt::engine@wrapper.jsc"_T);
        static constexpr coid::token _dlua("xt::engine@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<engine, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* {
            return new C;
        };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "xt::engine"_T;
        tmp << "@client-3500335767"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc, nullptr);

        return 0;
    }

protected:

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<engine>* pout);
};


inline auto engine::init_chassis(const coid::token& params) -> ot::vehicle_params { return VT_CALL(ot::vehicle_params,(const coid::token&),0)(params); }
inline auto engine::init_vehicle(bool reload) -> void { return VT_CALL(void,(bool),1)(reload); }
inline auto engine::update_frame(float dt, float engine, float brake, float steering, float parking) -> void { return VT_CALL(void,(float,float,float,float,float),2)(dt,engine,brake,steering,parking); }
inline auto engine::update_actions_script(float dt, const coid::range<int32>& actbuf) -> void { return VT_CALL(void,(float,const coid::range<int32>&),3)(dt,actbuf); }

} //namespace

#endif //_INTERGEN_GENERATED__engine_H_
