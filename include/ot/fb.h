#pragma once

#ifndef _INTERGEN_GENERATED__fb_H_
#define _INTERGEN_GENERATED__fb_H_

//@file Interface file for fb interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::framebuffer

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include <ot/location_cfg.h>
#include <ot/sdm_types.h>

class framebuffer;


namespace ot {

////////////////////////////////////////////////////////////////////////////////

class fb
    : public intergen_interface
{
public:

    // --- interface methods ---

    void nvg_enable( bool enable );

    bool is_nvg_enabled() const;

    
    void set_nvg_params( float contrast, float amplify, float noise );

    void set_nvg_color( const float3& color );

    void ar_enable( bool enable );

    bool is_ar_enabled() const;

    void ir_enable( bool enable );

    bool is_ir_enabled() const;

    
    void set_ir_params( float contrast, float amplify, float noise );

    const uint* get_temperature_histogram() const;

    void enable_thermal_autogain( bool enable );

    void set_thermal_params( float sensor_temperature_black, float sensor_temperature_white, float air_temperature, float water_temperature, float air_temperature_daytime_coef );

    void enable_thermal_scientific_mode( bool enable );

    ///
    void set_sdm_mesh( const ot::sdm_vertex* ptr, uint nvertices, const uint* indices, uint nindices, const float2& fov );

    void set_max_bloom_level( uint lev );

    // --- creators ---

    static iref<fb> get() {
        return get<fb>(0);
    }

    template<class T>
    static iref<T> get( T* _subclass_ );

    // --- internal helpers ---

    virtual ~fb() {
        if (_cleaner)
            _cleaner(this, 0);
    }

    ///Interface revision hash
    static const int HASHID = 2171447498u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::fb"_T;
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( backend bck ) {
        static constexpr coid::token _dc("ot::fb.get@2171447498"_T);
        static constexpr coid::token _djs("ot::fb@wrapper.js"_T);
        static constexpr coid::token _djsc("ot::fb@wrapper.jsc"_T);
        static constexpr coid::token _dlua("ot::fb@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }

    //@return cached active interface of given host class
    //@note host side helper
    static iref<fb> intergen_active_interface(::framebuffer* host);


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override final {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<fb, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::fb"_T;
        tmp << "@client-2171447498"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    ///Cleanup routine called from ~fb()
    static void _cleaner_callback(fb* m, intergen_interface* ifc) {
        m->assign_safe(ifc, 0);
    }

    bool assign_safe(intergen_interface* client__, iref<fb>* pout);

    typedef void (*cleanup_fn)(fb*, intergen_interface*);
    cleanup_fn _cleaner = 0;

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<fb>* pout);
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> fb::get( T* _subclass_ )
{
    typedef iref<T> (*fn_creator)(fb*);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::fb.get@2171447498"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("get"_T, "ot::fb.get"_T, "@2171447498"_T);
        return 0;
    }

    return create(_subclass_);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline void fb::nvg_enable( bool enable )
{ return VT_CALL(void,(bool),0)(enable); }

inline bool fb::is_nvg_enabled() const
{ return VT_CALL(bool,() const,1)(); }

inline void fb::set_nvg_params( float contrast, float amplify, float noise )
{ return VT_CALL(void,(float,float,float),2)(contrast,amplify,noise); }

inline void fb::set_nvg_color( const float3& color )
{ return VT_CALL(void,(const float3&),3)(color); }

inline void fb::ar_enable( bool enable )
{ return VT_CALL(void,(bool),4)(enable); }

inline bool fb::is_ar_enabled() const
{ return VT_CALL(bool,() const,5)(); }

inline void fb::ir_enable( bool enable )
{ return VT_CALL(void,(bool),6)(enable); }

inline bool fb::is_ir_enabled() const
{ return VT_CALL(bool,() const,7)(); }

inline void fb::set_ir_params( float contrast, float amplify, float noise )
{ return VT_CALL(void,(float,float,float),8)(contrast,amplify,noise); }

inline const uint* fb::get_temperature_histogram() const
{ return VT_CALL(const uint*,() const,9)(); }

inline void fb::enable_thermal_autogain( bool enable )
{ return VT_CALL(void,(bool),10)(enable); }

inline void fb::set_thermal_params( float sensor_temperature_black, float sensor_temperature_white, float air_temperature, float water_temperature, float air_temperature_daytime_coef )
{ return VT_CALL(void,(float,float,float,float,float),11)(sensor_temperature_black,sensor_temperature_white,air_temperature,water_temperature,air_temperature_daytime_coef); }

inline void fb::enable_thermal_scientific_mode( bool enable )
{ return VT_CALL(void,(bool),12)(enable); }

inline void fb::set_sdm_mesh( const ot::sdm_vertex* ptr, uint nvertices, const uint* indices, uint nindices, const float2& fov )
{ return VT_CALL(void,(const ot::sdm_vertex*,uint,const uint*,uint,const float2&),13)(ptr,nvertices,indices,nindices,fov); }

inline void fb::set_max_bloom_level( uint lev )
{ return VT_CALL(void,(uint),14)(lev); }

#pragma warning(pop)

} //namespace

#endif //_INTERGEN_GENERATED__fb_H_
