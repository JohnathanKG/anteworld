#pragma once

#ifndef _INTERGEN_GENERATED__geomob_H_
#define _INTERGEN_GENERATED__geomob_H_

//@file Interface file for geomob interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::pkg::geomob

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>


#include <ot/glm/glm_meta.h>
#include <ot/geom_types.h>
#include <ot/object_cfg.h>
#include <ot/glm/glm_types.h>



namespace ot {
    class geomob;
    class canvas;
}

namespace pkg
{
    struct lod_meshes;
    struct mesh_draw_data2;
    struct knob_control;
    struct knob_action_data;
    class obj_def;
}

#include <ot/canvas.h>

namespace pkg {
    class geomob;
}


namespace ot {

////////////////////////////////////////////////////////////////////////////////
///Geometry instance interface
class geomob
    : public intergen_interface
{
public:

    // --- interface methods ---

#pragma warning(push)
#pragma warning(disable : 4191)

    //@return object's position, relative to parent or global (ECEF) for root objects
    const double3& get_pos() const
    { return VT_CALL(const double3&,() const,0)(); }

    //@return object's rotation quaternion, relative to parent or a global rotation (+z up, +y forward) in ECEF
    const quat& get_rot() const
    { return VT_CALL(const quat&,() const,1)(); }

    ///
    uint get_first_bone() const
    { return VT_CALL(uint,() const,2)(); }

    //@return object's local position (relative to parent or a zero vector)
    float3 get_local_pos() const
    { return VT_CALL(float3,() const,3)(); }

    //@return object's local rotation quaternion (relative to parent or a unit rotation)
    quat get_local_rot() const
    { return VT_CALL(quat,() const,4)(); }

    //@return object's world (ECEF) position
    double3 get_ecef_pos() const
    { return VT_CALL(double3,() const,5)(); }

    //@return object's world (ECEF) rotation quaternion
    quat get_ecef_rot() const
    { return VT_CALL(quat,() const,6)(); }

    entity_handle get_inst_id() const
    { return VT_CALL(entity_handle,() const,7)(); }

    //@return world position of OBB center
    double3 get_pos_obb_center() const
    { return VT_CALL(double3,() const,8)(); }

    ///Get world position of a point in model's relative offset
    double3 get_world_pos_offset( const float3& offset, uint bone = pkg::InvalidBoneId ) const
    { return VT_CALL(double3,(const float3&,uint) const,9)(offset,bone); }

    //@return instance scale
    const float3& get_scale() const
    { return VT_CALL(const float3&,() const,10)(); }

    void set_scale( const float3& scale )
    { return VT_CALL(void,(const float3&),11)(scale); }

    ///Set object's world position (ECEF)
    void set_pos( const double3& pos )
    { return VT_CALL(void,(const double3&),12)(pos); }

    void move( const float3& vec )
    { return VT_CALL(void,(const float3&),13)(vec); }

    ///Set object's rotation quaternion (rotation of model (+z up, +y forward) in ECEF)
    void set_rot( const quat& rot )
    { return VT_CALL(void,(const quat&),14)(rot); }

    void add_rot( const quat& rot )
    { return VT_CALL(void,(const quat&),15)(rot); }

    void set_pos_rot( const double3& pos, const quat& rot )
    { return VT_CALL(void,(const double3&,const quat&),16)(pos,rot); }

    ///Remove object from the scene
    void remove_from_scene()
    { return VT_CALL(void,(),17)(); }

    ///
    uint get_children_count() const
    { return VT_CALL(uint,() const,18)(); }

    entity_handle get_child_entity_id( uint local_child_index ) const
    { return VT_CALL(entity_handle,(uint) const,19)(local_child_index); }

    const coid::charstr& get_objurl() const
    { return VT_CALL(const coid::charstr&,() const,20)(); }

    
    bool get_objdef_info( ifc_out ot::pkginfo::objdef& info ) const
    { return VT_CALL(bool,(ot::pkginfo::objdef&) const,21)(info); }

    ushort get_lod_count() const
    { return VT_CALL(ushort,() const,22)(); }

    bool has_collision_geometry() const
    { return VT_CALL(bool,() const,23)(); }

    const pkg::mesh_lod_group* get_collision_lod() const
    { return VT_CALL(const pkg::mesh_lod_group*,() const,24)(); }

    ///Get vector from the model pivot into the center of the OBB
    float3 get_obb_offset() const
    { return VT_CALL(float3,() const,25)(); }

    ///
    float3 get_pivot() const
    { return VT_CALL(float3,() const,26)(); }

    ///Get OBB's diagonal half-vector
    float3 get_obb_hvec() const
    { return VT_CALL(float3,() const,27)(); }

    const pkg::geom_instance_data* get_geom_instance_data_ptr() const
    { return VT_CALL(const pkg::geom_instance_data*,() const,28)(); }

    
    /// return entity ID
    entity_handle get_eid() const
    { return VT_CALL(entity_handle,() const,29)(); }

    /// set/get uint32 (used by scene editor)
    void set_custom_data( uint custom_data ) const
    { return VT_CALL(void,(uint) const,30)(custom_data); }

    uint get_custom_data() const
    { return VT_CALL(uint,() const,31)(); }

    
    //@return local joint id it's on geom only to get global ID add get_bones_base()
    uint get_joint( const coid::token& name ) const
    { return VT_CALL(uint,(const coid::token&) const,32)(name); }

    
    //@param name
    //@param lod_group - log group for given base name (0xff if all lod groups)
    //@param mat_group - material group for given base name (0xff if all material groups)
    //@return mesh id for given params
    //@note returned value contains 2 flags on first two MSB. First bit is 1 if all lod groups are contained. Second bit is 1 if all material groups are contained.
    uint get_mesh_id( const coid::token& name, uint8 lod_group = 0xff, uint8 mat_group = 0xff ) const
    { return VT_CALL(uint,(const coid::token&,uint8,uint8) const,33)(name,lod_group,mat_group); }

    ///Show/hide bone hierarchy - not implemented yet
    void set_joint_visible( uint joint, bool visible, bool recursive = true )
    { return VT_CALL(void,(uint,bool,bool),34)(joint,visible,recursive); }

    ///Rotate bone along an axis (incremental)
    void reset_joint( uint bone_id )
    { return VT_CALL(void,(uint),35)(bone_id); }

    ///Rotate bone along an axis (incremental)
    //@param bone_id
    //@param angle rotation angle in radians
    //@param vec rotation axis vector (MUST BE normalized)
    //@param orig true if rotation should go from the bind pose, otherwise accumulate
    void rotate_joint( uint bone_id, float angle, const float3& vec, bool orig = false )
    { return VT_CALL(void,(uint,float,const float3&,bool),36)(bone_id,angle,vec,orig); }

    ///Rotate bone along an axis (from default orientation)
    //@param bone_id
    //@param angle rotation angle in radians
    //@param vec rotation axis vector (MUST BE normalized)
    void rotate_joint_orig( uint bone_id, float angle, const float3& vec )
    { return VT_CALL(void,(uint,float,const float3&),37)(bone_id,angle,vec); }

    void rotate_joint_cs( uint bone_id, float cos_angle, float sin_angle, const float3& vec, bool orig = false )
    { return VT_CALL(void,(uint,float,float,const float3&,bool),38)(bone_id,cos_angle,sin_angle,vec,orig); }

    void rotate_joint_cs_orig( uint bone_id, float cos_angle, float sin_angle, const float3& vec )
    { return VT_CALL(void,(uint,float,float,const float3&),39)(bone_id,cos_angle,sin_angle,vec); }

    ///Move bone (incremental)
    //@param orig true if movement should go from the bind pose, otherwise accumulate
    void move_joint( uint bone_id, const float3& vec, bool orig = false )
    { return VT_CALL(void,(uint,const float3&,bool),40)(bone_id,vec,orig); }

    ///Move bone (from default position)
    void move_joint_orig( uint joint, const float3& vec )
    { return VT_CALL(void,(uint,const float3&),41)(joint,vec); }

    ///Mesh visibility control
    //@param name mesh name
    //@note if the last char is @ it will disable all submeshes with suffix @1-@N (submeshes appear because of multi-materials used within mesh)
    //@note if the last char * it will disable all submeshes that begin with given name
    void set_mesh_visible( coid::token name, bool show )
    { return VT_CALL(void,(coid::token,bool),42)(name,show); }

    ///Mesh visibility with mesh ID
    //@param id - id from get_mesh_id with additional flags.
    //@note See get_mesh_id documentation
    void set_mesh_visible_id( uint id, bool show )
    { return VT_CALL(void,(uint,bool),43)(id,show); }

    ///Mesh and shadow visibility control
    //@param name mesh name
    //@note if the last char is @ it will disable all submeshes with suffix @1-@N (submeshes appear because of multi-materials used within mesh)
    //@note if the last char * it will disable all submeshes that begin with given name
    void set_mesh_and_shadow_visible( coid::token name, bool show_mesh, bool show_shadow )
    { return VT_CALL(void,(coid::token,bool,bool),44)(name,show_mesh,show_shadow); }

    ///Mesh visibility and shadow with mesh ID
    //@param id - id from get_mesh_id with additional flags.
    //@note See get_mesh_id documentation
    void set_mesh_and_shadow_visible_id( uint id, bool show_mesh, bool show_shadow )
    { return VT_CALL(void,(uint,bool,bool),45)(id,show_mesh,show_shadow); }

    //@return joint position in model space
    float3 get_joint_model_pos( uint joint ) const
    { return VT_CALL(float3,(uint) const,46)(joint); }

    //@return joint position in ecef space
    double3 get_joint_ecef_pos( uint joint ) const
    { return VT_CALL(double3,(uint) const,47)(joint); }

    //@return joint transformation in ecef
    bool get_joint_ecef_tm( uint joint, ifc_out double3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,double3&,quat&) const,48)(joint,pos,rot); }

    //@return joint position in ecef space
    float3 get_joint_ecef_rot_z( uint joint ) const
    { return VT_CALL(float3,(uint) const,49)(joint); }

    //@return joint position in model space (compatibility)
    float3 get_joint_local_pos( uint joint ) const
    { return VT_CALL(float3,(uint) const,50)(joint); }

    ///
    
    ///Deselect object previously selected via object_factory
    void deselect()
    { return VT_CALL(void,(),51)(); }

    
    //@return number of bones
    uint get_num_bones() const
    { return VT_CALL(uint,() const,52)(); }

    //@return constant pointer to bones meta information (parent IDs)
    const pkg::bone_meta2* get_bone_meta_ptr() const
    { return VT_CALL(const pkg::bone_meta2*,() const,53)(); }

    //@return constant pointer to bones description (bone name, etc)
    const pkg::bone_desc* get_bone_desc_ptr() const
    { return VT_CALL(const pkg::bone_desc*,() const,54)(); }

    //@return constant pointer to inverse bind pose transformations
    const pkg::bone_data* get_bone_ibp_ptr() const
    { return VT_CALL(const pkg::bone_data*,() const,55)(); }

    //@return constant pointer to bones bind pose local transformations
    const pkg::bone_data* get_bone_bp_local_ptr() const
    { return VT_CALL(const pkg::bone_data*,() const,56)(); }

    //@return number of knobs
    uint get_num_knobs()
    { return VT_CALL(uint,(),57)(); }

    //@return constant pointer to knob controls
    const pkg::knob_control* get_knob_controls_ptr() const
    { return VT_CALL(const pkg::knob_control*,() const,58)(); }

    //@return constan pointer to knob controls data
    const pkg::knob_action_data* get_knob_actions_data_ptr() const
    { return VT_CALL(const pkg::knob_action_data*,() const,59)(); }

    /// return pointer to bones local transformations,
    /// these transformations are later recomputed to world space transformations and used in shader
    ///
    /// Updates to this array have no effect if raw_bones_update is enabled!
    ///
    /// BE VERY CAREFUL HOW MUCH DATA YOU ARE WRITING TO THIS MEMORY !!!
    ///
    pkg::bone_data* get_bone_local_ptr() const
    { return VT_CALL(pkg::bone_data*,() const,60)(); }

    
    ///Show/hide whole geom object
    void set_visible( bool visible )
    { return VT_CALL(void,(bool),61)(visible); }

    ///Make object visible or invisible on the slave
    //@note all objects are visible by default
    
    //@return true if the geom's visible flag is true
    bool is_visible() const
    { return VT_CALL(bool,() const,62)(); }

    //@return true if the geom is fully loaded
    bool is_ready() const
    { return VT_CALL(bool,() const,63)(); }

    ///Get current bone model space transformation from previous frame
    bool get_bone_model_dq( uint joint, ifc_out quat& rot, ifc_out quat& dual ) const
    { return VT_CALL(bool,(uint,quat&,quat&) const,64)(joint,rot,dual); }

    bool get_bone_model_tm( uint joint, ifc_out float3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,float3&,quat&) const,65)(joint,pos,rot); }

    ///Return bone model space transformation from previous frame, with extra offset
    bool get_bone_model_tm_offset( uint joint, const float3& offset, ifc_out float3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,const float3&,float3&,quat&) const,66)(joint,offset,pos,rot); }

    ///Get bone bind pose ecef space transformation (iverse of IBP)
    bool get_bone_ecef_bp_tm( uint joint, ifc_out double3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,double3&,quat&) const,67)(joint,pos,rot); }

    ///Get bone bind pose model space transformation (iverse of IBP)
    bool get_bone_model_bp_dq( uint joint, ifc_out quat& rot, ifc_out quat& dual ) const
    { return VT_CALL(bool,(uint,quat&,quat&) const,68)(joint,rot,dual); }

    bool get_bone_model_bp_tm( uint joint, ifc_out float3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,float3&,quat&) const,69)(joint,pos,rot); }

    //@returns bone skin transformation previous frame
    const pkg::bone_gpu_data* get_bone_skin_dq( uint bone_id ) const
    { return VT_CALL(const pkg::bone_gpu_data*,(uint) const,70)(bone_id); }

    ///Get current bone local space transformation from parent
    bool get_bone_local_dq( uint joint, ifc_out quat& rot, ifc_out quat& dual ) const
    { return VT_CALL(bool,(uint,quat&,quat&) const,71)(joint,rot,dual); }

    bool get_bone_local_tm( uint joint, ifc_out float3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,float3&,quat&) const,72)(joint,pos,rot); }

    const pkg::mesh_desc* get_meshes_ptr() const
    { return VT_CALL(const pkg::mesh_desc*,() const,73)(); }

    const pkg::mesh_data_cpu* get_meshes_data_ptr() const
    { return VT_CALL(const pkg::mesh_data_cpu*,() const,74)(); }

    const pkg::mesh_lod_group* get_lods_ptr() const
    { return VT_CALL(const pkg::mesh_lod_group*,() const,75)(); }

    const pkg::mesh_lod_group* get_collision_meshes_ptr() const
    { return VT_CALL(const pkg::mesh_lod_group*,() const,76)(); }

    ushort* get_mesh_flags_ptr() const
    { return VT_CALL(ushort*,() const,77)(); }

    
    const pkg::mesh_data_static_cpu* get_mesh_data_static_ptr()
    { return VT_CALL(const pkg::mesh_data_static_cpu*,(),78)(); }

    coid::dynarray<pkg::mesh_desc> get_meshes() const
    { return VT_CALL(coid::dynarray<pkg::mesh_desc>,() const,79)(); }

    coid::dynarray<pkg::mesh_lod_group> get_lods() const
    { return VT_CALL(coid::dynarray<pkg::mesh_lod_group>,() const,80)(); }

    pkg::mesh_lod_group get_collision_meshes() const
    { return VT_CALL(pkg::mesh_lod_group,() const,81)(); }

    coid::dynarray<ushort> get_mesh_flags() const
    { return VT_CALL(coid::dynarray<ushort>,() const,82)(); }

    ///Collision mesh world transformation with mesh_id
    //@param mesh_id - mesh id of collision mesh.
    //@param pos - world position of collision shape
    //@param rot - world rotation of collision shape
    //@return false if given mesh_id was wrong
    bool get_collision_mesh_ecef_tm( uint mesh_id, ifc_out double3& pos, ifc_out quat& rot ) const
    { return VT_CALL(bool,(uint,double3&,quat&) const,83)(mesh_id,pos,rot); }

    ///
    void attach_to( const iref<ot::geomob>& geom, uint joint_id = pkg::InvalidBoneId, bool update_tm = true )
    { return VT_CALL(void,(const iref<ot::geomob>&,uint,bool),84)(geom,joint_id,update_tm); }

    ///
    entity_handle attach_geom( const coid::token& url, const coid::token& joint, const double3& pos, const quat& rot )
    { return VT_CALL(entity_handle,(const coid::token&,const coid::token&,const double3&,const quat&),85)(url,joint,pos,rot); }

    ///
    void get_world_transform( ifc_out double3& pos, ifc_out quat& rot ) const
    { return VT_CALL(void,(double3&,quat&) const,86)(pos,rot); }

    ///
    void dump_geom_info()
    { return VT_CALL(void,(),87)(); }

    ///
    uint get_mtl_count() const
    { return VT_CALL(uint,() const,88)(); }

    ///
    uint get_mtl_id( uint id ) const
    { return VT_CALL(uint,(uint) const,89)(id); }

    int8 get_internal_temperature( uint idx ) const
    { return VT_CALL(int8,(uint) const,90)(idx); }

    void set_internal_temperature( uint idx, int8 temperature )
    { return VT_CALL(void,(uint,int8),91)(idx,temperature); }

    
    
    const pkg::mesh_data_static_cpu* get_mesh_data_static_cpu( uint mesh ) const
    { return VT_CALL(const pkg::mesh_data_static_cpu*,(uint) const,92)(mesh); }

    ///
    const int2* get_positions( const pkg::mesh_data_static_cpu* mds ) const
    { return VT_CALL(const int2*,(const pkg::mesh_data_static_cpu*) const,93)(mds); }

    const ushort* get_indices( const pkg::mesh_data_static_cpu* mds ) const
    { return VT_CALL(const ushort*,(const pkg::mesh_data_static_cpu*) const,94)(mds); }

    
    
    /// convert internal float4x3 mesh matrix to dual quaternion
    void get_mesh_model_tm( uint mesh_id, ifc_out quat& rot, ifc_out quat& dual ) const
    { return VT_CALL(void,(uint,quat&,quat&) const,95)(mesh_id,rot,dual); }

    /// return float4x3 matrix directly from internal data
    void get_mesh_model_tm( uint mesh_id, ifc_out float4x3& tm ) const
    { return VT_CALL(void,(uint,float4x3&) const,96)(mesh_id,tm); }

    
    
    ///
    uint create_dynamic_lightmap( uint width, uint height )
    { return VT_CALL(uint,(uint,uint),97)(width,height); }

    ///
    void destroy_dynamic_lightmap( uint lightmap_id )
    { return VT_CALL(void,(uint),98)(lightmap_id); }

    ///
    uint get_dynamic_lightmap_id() const
    { return VT_CALL(uint,() const,99)(); }

    ///
    uint add_light_block( uint x, uint y, uint width, uint height )
    { return VT_CALL(uint,(uint,uint,uint,uint),100)(x,y,width,height); }

    ///
    void remove_light_block( uint light_block_id )
    { return VT_CALL(void,(uint),101)(light_block_id); }

    ///
    void turn_on_block( uint light_block_id, uint rgbi )
    { return VT_CALL(void,(uint,uint),102)(light_block_id,rgbi); }

    ///
    void turn_off_block( uint light_block_id )
    { return VT_CALL(void,(uint),103)(light_block_id); }

    ///
    void turn_off_lightmap()
    { return VT_CALL(void,(),104)(); }

    void set_emissive_multiplier( float m )
    { return VT_CALL(void,(float),105)(m); }

    float get_emissive_multiplier()
    { return VT_CALL(float,(),106)(); }

    short get_excluded_passes() const
    { return VT_CALL(short,() const,107)(); }

    void add_excluded_pass( short pass_id )
    { return VT_CALL(void,(short),108)(pass_id); }

    void remove_excluded_pass( short pass_id )
    { return VT_CALL(void,(short),109)(pass_id); }

    coid::dynarray<coid::charstr> get_displays_names() const
    { return VT_CALL(coid::dynarray<coid::charstr>,() const,110)(); }

#pragma warning(pop)
    // --- creators ---

    /// create geom instance
    ///@url geom URL like "outerra/m4/m4"
    ///@parent_id parent entity ID, can be get with geom::get_eid() or use -1
    ///@parent_joint_id parent's geom joint ID or 0xffff
    static iref<geomob> create( const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id ) {
        return create<geomob>(0, url, parent_entity_id, parent_joint_id);
    }

    template<class T>
    static iref<T> create( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id );

    /// create geom instance and return new geom interface
    ///@url geom URL like "outerra/m4/m4"
    ///@parent_id parent entity ID, can be get with geom::get_eid() or use -1
    ///@parent_joint_id parent's geom joint ID or 0xffff
    ///@pos position
    ///@rot rotation
    static iref<geomob> create2( const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id, const double3& pos, const quat& rot ) {
        return create2<geomob>(0, url, parent_entity_id, parent_joint_id, pos, rot);
    }

    template<class T>
    static iref<T> create2( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id, const double3& pos, const quat& rot );

    /// create geom instance and return new geom interface
    ///@url geom URL like "outerra/m4/m4"
    ///@parent_id parent entity ID, can be get with geom::get_eid() or use -1
    ///@parent_joint parent's joint name or null
    ///@pos position
    ///@rot rotation
    static iref<geomob> create3( const coid::token& url, entity_handle parent_entity_id, const coid::token& parent_joint, const double3& pos, const quat& rot ) {
        return create3<geomob>(0, url, parent_entity_id, parent_joint, pos, rot);
    }

    template<class T>
    static iref<T> create3( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, const coid::token& parent_joint, const double3& pos, const quat& rot );

    /// return geomob component interface from entity
    static iref<geomob> from_entity_id( entity_handle entity_id ) {
        return from_entity_id<geomob>(0, entity_id);
    }

    template<class T>
    static iref<T> from_entity_id( T* _subclass_, entity_handle entity_id );

    ///Interface creator for internal use
    static iref<geomob> _get_instance_interface( void* so ) {
        return _get_instance_interface<geomob>(0, so);
    }

    template<class T>
    static iref<T> _get_instance_interface( T* _subclass_, void* so );

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = 4139621978u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::geomob"_T;
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( backend bck ) {
        static constexpr coid::token _dc(""_T);
        static constexpr coid::token _djs("ot::geomob@wrapper.js"_T);
        static constexpr coid::token _djsc("ot::geomob@wrapper.jsc"_T);
        static constexpr coid::token _dlua("ot::geomob@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override final {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<geomob, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::geomob"_T;
        tmp << "@client-4139621978"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<geomob>* pout);
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> geomob::create( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id )
{
    typedef iref<T> (*fn_creator)(geomob*, const coid::token&, entity_handle, coid::uint);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::geomob.create@4139621978"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create"_T, "ot::geomob.create"_T, "@4139621978"_T);
        return 0;
    }

    return create(_subclass_, url, parent_entity_id, parent_joint_id);
}

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> geomob::create2( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, coid::uint parent_joint_id, const double3& pos, const quat& rot )
{
    typedef iref<T> (*fn_creator)(geomob*, const coid::token&, entity_handle, coid::uint, const double3&, const quat&);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::geomob.create2@4139621978"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create2"_T, "ot::geomob.create2"_T, "@4139621978"_T);
        return 0;
    }

    return create(_subclass_, url, parent_entity_id, parent_joint_id, pos, rot);
}

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> geomob::create3( T* _subclass_, const coid::token& url, entity_handle parent_entity_id, const coid::token& parent_joint, const double3& pos, const quat& rot )
{
    typedef iref<T> (*fn_creator)(geomob*, const coid::token&, entity_handle, const coid::token&, const double3&, const quat&);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::geomob.create3@4139621978"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create3"_T, "ot::geomob.create3"_T, "@4139621978"_T);
        return 0;
    }

    return create(_subclass_, url, parent_entity_id, parent_joint, pos, rot);
}

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> geomob::from_entity_id( T* _subclass_, entity_handle entity_id )
{
    typedef iref<T> (*fn_creator)(geomob*, entity_handle);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::geomob.from_entity_id@4139621978"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("from_entity_id"_T, "ot::geomob.from_entity_id"_T, "@4139621978"_T);
        return 0;
    }

    return create(_subclass_, entity_id);
}

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> geomob::_get_instance_interface( T* _subclass_, void* so )
{
    typedef iref<T> (*fn_creator)(geomob*, void*);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::geomob._get_instance_interface@4139621978"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("_get_instance_interface"_T, "ot::geomob._get_instance_interface"_T, "@4139621978"_T);
        return 0;
    }

    return create(_subclass_, so);
}

} //namespace

#endif //_INTERGEN_GENERATED__geomob_H_
