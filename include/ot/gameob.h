#pragma once

#ifndef _INTERGEN_GENERATED__gameob_H_
#define _INTERGEN_GENERATED__gameob_H_

//@file Interface file for gameob interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::game_object

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include <ot/action_cfg.h>
#include <ot/object_cfg.h>
#include <ot/geomob.h>

class game_object;


namespace ot {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////////
///Interface for scriptable game objects
class gameob
    : public intergen_interface
{
    const uint _inhmask = 1;

public:

    // --- interface methods ---

#pragma warning(push)
#pragma warning(disable : 4191)

    ///Register input action sending events on button press (value > 0)
    //@param name hierarchic action name (prefix $ for server event [MP only])
    //@param handler optional handler for changed value
    //@param handler_id optional extra data for the handler
    //@param channels number of extra channels that are handled (multiple engines etc)
    //@param group activation group where the action is assigned (can be enabled/disabled together)
    //@return slot id or -1 on fail
    int register_event_handler( const coid::token& name, ot::fn_event_action&& handler, int handler_id = 0, uint channels = 0, uint group = 0 )
    { return VT_CALL(int,(const coid::token&,ot::fn_event_action&&,int,uint,uint),0)(name,std::forward<ot::fn_event_action>(handler),handler_id,channels,group); }

    ///Register input action sending events on value change (full state button and axis)
    //@param name hierarchic action name (prefix $ for server event [MP only])
    //@param handler optional handler for changed value
    //@param handler_id optinal extra data for the handler
    //@param defval default action value
    //@param ramp value limiter parameters
    //@param group activation group where the action is assigned (can be enabled/disabled together)
    //@return slot id or -1 on fail
    int register_axis_handler( const coid::token& name, ot::fn_axis_action&& handler, int handler_id, float defval, const ot::ramp_params& ramp, uint group = 0 )
    { return VT_CALL(int,(const coid::token&,ot::fn_axis_action&&,int,float,const ot::ramp_params&,uint),1)(name,std::forward<ot::fn_axis_action>(handler),handler_id,defval,ramp,group); }

    ///Register event action handler
    //@param name hierarchic action name, file/group/action
    //@param group activation group where the action is assigned (can be enabled/disabled together)
    //@param channels number of extra channels that the handler supports
    //@return slot id or -1 on fail
    int register_event_ext( const coid::token& name, uint group = 0, uint channels = 0 )
    { return VT_CALL(int,(const coid::token&,uint,uint),2)(name,group,channels); }

    ///Register axis action handler
    //@param name hierarchic action name, file/group/action
    //@param ramp value limiter parameters (ignored for buttons)
    //@param defval initial value for the axis
    //@param group activation group where the action is assigned (can be enabled/disabled together)
    //@return slot id or -1 on fail
    int register_axis_ext( const coid::token& name, const ot::ramp_params& ramp, float defval = 0, uint group = 0 )
    { return VT_CALL(int,(const coid::token&,const ot::ramp_params&,float,uint),3)(name,ramp,defval,group); }

    ///Activate or deactivate given action group
    //@params group group id
    //@param activate activate/deactivate the group
    void action_group( uint group, bool activate )
    { return VT_CALL(void,(uint,bool),4)(group,activate); }

    //@param id 0 the main body
    iref<ot::geomob> get_geomob( int id )
    { return VT_CALL(iref<ot::geomob>,(int),5)(id); }

    ///Set model space position for FPS camera
    void set_fps_camera_pos( const float3& pos, uint joint_id = UMAX32, ot::EJointRotationMode joint_rotation = ot::JointRotModeEnable )
    { return VT_CALL(void,(const float3&,uint,ot::EJointRotationMode),6)(pos,joint_id,joint_rotation); }

    ///Set model space rotation frame
    //@param rot model space rotation
    //@param mouse rotation mode: 0 freeze, 1 reset&disable, 2 enable, 3 reset & enable
    //@param use bone rotation if true, bone rotation is applied
    void set_fps_camera_rot( const quat& rot, ot::ERotationMode mouse_rotation )
    { return VT_CALL(void,(const quat&,ot::ERotationMode),7)(rot,mouse_rotation); }

    ///Set FOV to chassis fps preset and also to current camera if vehicle is entered and fpc camera is active
    //@param hfov horizontal fov in degrees, 0 to reset to the default one
    //@param vfov optional vertical fov in degrees, otherwise computed from aspect ratio
    void set_fps_camera_fov( float hfov, float vfov = 0 )
    { return VT_CALL(void,(float,float),8)(hfov,vfov); }

    //@return current FPS camera position
    //@note same value for given class (chassis) of vehicles
    float3 get_fps_camera_pos() const
    { return VT_CALL(float3,() const,9)(); }

    //@return current FPS camera rotation in model space
    //@param base true for the base orientation frame, false for current camera orientation as altered by mouse
    //@note same value for given class (chassis) of vehicles
    quat get_fps_camera_rot( bool base = false ) const
    { return VT_CALL(quat,(bool) const,10)(base); }

    ///Get FPS camera preset FOV for this chassis
    //@param hfov horizontal fov in degrees, 0 to reset to the default one
    //@param vfov optional vertical fov in degrees, otherwise computed from aspect ratio
    float2 get_fps_camera_fov() const
    { return VT_CALL(float2,() const,11)(); }

    ///Move character relatively in tangent space
    //@param pos relative position in tangent space, x side, y forward, z up
    //@param yawd yaw angle delta [rad]
    //@param pitch angle [rad]
    //@note only dynamic game objects can move
    void move( const float3& pos, float yawd, float pitch )
    { return VT_CALL(void,(const float3&,float,float),12)(pos,yawd,pitch); }

    ///Set rotation
    //@param fwd forward vector to align to
    void rotate( const float3& fwd )
    { return VT_CALL(void,(const float3&),13)(fwd); }

    ///Find distance above terrain
    //@param pos offset from object pos (offset is in tangent space)
    //@param maxlen max distance to check (optimization)
    //@return distances to terrain layers (hard, soft, and water), maxlen if not found within the maxlen distance
    float3 elevation_above_terrain( const float3& pos, float maxlen ) const
    { return VT_CALL(float3,(const float3&,float) const,14)(pos,maxlen); }

    ///Return current solar time and cosine of sun-zenith angle
    //@param time [out] solar time at object location, in miliseconds
    //@param sun_coef sun position relative to horizon: 0 sun at horizon, 1 sun at zenith, -1 sun at anti-zenith
    void solar_time( ifc_out double& time, ifc_out float& sun_coef ) const
    { return VT_CALL(void,(double&,float&) const,15)(time,sun_coef); }

    ///Return current solar day
    //@param day [out] solar day at object location <0, 365>
    void solar_day_of_year( ifc_out double& day ) const
    { return VT_CALL(void,(double&) const,16)(day); }

#pragma warning(pop)

protected:
    // --- interface events (callbacks from host to client) ---
    // ---       overload these to handle host events       ---

    friend class ::game_object;

    ///Initialize chassis (shared across all gameob instances of the same type)
    //@param info url, custom parameters from objdef, path to the directory with pkg file
    virtual void init_chassis( const ot::objdef_params& info ) {}

    virtual void init_chassis_script( const ot::objdef_params& info ) {}

    ///Initialize instance
    virtual void init( const ot::objdef_params& info ) {}

    ///Interface event for handling aircraft state before rendering (inputs, animating joints etc)
    virtual void update_actions_script( float dt, const coid::range<int32>& actbuf ) {}

    ///Update model instance for rendering
    //@param dt delta time since last update call (elapsed time)
    //@param dtinterp time to interpolate ahead from the last simulation state
    virtual void visual_update( float dt, float dtinterp ) {}

    virtual void simulation_step( float dt ) {}

    virtual void force_bind_script_events() {}

public:
    // --- host helpers to check presence of handlers in scripts ---

    virtual bool is_bound_init_chassis() { return true; }
    virtual bool is_bound_init_chassis_script() { return true; }
    virtual bool is_bound_init() { return true; }
    virtual bool is_bound_update_actions_script() { return true; }
    virtual bool is_bound_visual_update() { return true; }
    virtual bool is_bound_simulation_step() { return true; }

public:
    // --- creators ---

    // --- internal helpers ---

    virtual ~gameob() {
        if (_cleaner)
            _cleaner(this, 0);
    }

    ///Interface revision hash
    static const int HASHID = 2050995500u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::gameob"_T;
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( backend bck ) {
        static constexpr coid::token _dc(""_T);
        static constexpr coid::token _djs("ot::gameob@wrapper.js"_T);
        static constexpr coid::token _djsc("ot::gameob@wrapper.jsc"_T);
        static constexpr coid::token _dlua("ot::gameob@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }

    //@return cached active interface of given host class
    //@note host side helper
    static iref<gameob> intergen_active_interface(::game_object* host);


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override final {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<gameob, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::gameob"_T;
        tmp << "@client-2050995500"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    static coid::comm_mutex& share_lock() {
        static coid::comm_mutex _mx(500, false);
        return _mx;
    }

    ///Cleanup routine called from ~gameob()
    static void _cleaner_callback(gameob* m, intergen_interface* ifc) {
        m->assign_safe(ifc, 0);
    }

    bool assign_safe(intergen_interface* client__, iref<gameob>* pout);

    typedef void (*cleanup_fn)(gameob*, intergen_interface*);
    cleanup_fn _cleaner = 0;

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<gameob>* pout);
};

} //namespace

#endif //_INTERGEN_GENERATED__gameob_H_
