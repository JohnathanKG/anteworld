#pragma once

#ifndef _INTERGEN_GENERATED__pkgview_H_
#define _INTERGEN_GENERATED__pkgview_H_

//@file Interface file for pkgview interface generated by intergen
//See LICENSE file for copyright and license information

//host class: ::ui::pkgview

#include <comm/commexception.h>
#include <comm/intergen/ifc.h>

#include <ot/object_cfg.h>

namespace ui {
    class pkgview;
}


namespace ot {

////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////////////////////
///OT pkgview interface
class pkgview
    : public intergen_interface
{
public:

    // --- interface methods ---

    ///Get pkg objects that satisfy the given criteria
    //@param categories a semicolon-separated list of categories to include, empty string for all
    //@param filter regex to be matched in description
    //@param tags a semicolon separated list of tags to look for, excluded tags start with !
    //@param res result set
    void set_filter( const coid::token& categories, const coid::token& filter, const coid::token& tags, const coid::token& package, ifc_out ot::pkginfo::result& res );

    ///Query range of items
    void query_range( uint offset, uint count, ifc_out coid::dynarray32<ot::pkginfo::object_entry>& res ) const;

    ///Sample package content
    //@param url pkg or item url
    //@param maxcount max number of items to return
    void sample_content( const coid::token& url, uint maxcount, ifc_out coid::dynarray32<ot::pkginfo::object_entry>& res ) const;

    ///Get package and root obj name
    //@param url pkg or item url
    //@param package package path
    //@param root root object path if the url refers to a skin
    //@param skin true if given url refers to a skin
    //@return true if url was found
    bool get_package( const coid::token& url, ifc_out coid::charstr& package, ifc_out coid::charstr& root, ifc_out bool& skin ) const;

    ///Get thumbnail as base64 encoded data
    //@param url object url
    //@param thumb_base64 base64 encoded image data ("data:image/gif;base64,"...)
    void get_thumbnail_data( const coid::token& url, ifc_out coid::charstr& thumb_base64 );

    // --- creators ---

    //@param name plugin name
    static iref<pkgview> create() {
        return create<pkgview>(0);
    }

    template<class T>
    static iref<T> create( T* _subclass_ );

    // --- internal helpers ---

    ///Interface revision hash
    static const int HASHID = 4282493147u;

    ///Interface name (full ns::class string)
    static const coid::tokenhash& IFCNAME() {
        static const coid::tokenhash _name = "ot::pkgview"_T;
        return _name;
    }

    int intergen_hash_id() const override final { return HASHID; }

    bool iface_is_derived( int hash ) const override final {
        return hash == HASHID;
    }

    const coid::tokenhash& intergen_interface_name() const override final {
        return IFCNAME();
    }

    static const coid::token& intergen_default_creator_static( backend bck ) {
        static constexpr coid::token _dc("ot::pkgview.create@4282493147"_T);
        static constexpr coid::token _djs("ot::pkgview@wrapper.js"_T);
        static constexpr coid::token _djsc("ot::pkgview@wrapper.jsc"_T);
        static constexpr coid::token _dlua("ot::pkgview@wrapper.lua"_T);
        static constexpr coid::token _dnone;

        switch(bck) {
        case backend::cxx: return _dc;
        case backend::js:  return _djs;
        case backend::jsc: return _djsc;
        case backend::lua: return _dlua;
        default: return _dnone;
        }
    }


#if _MSC_VER == 0 || _MSC_VER >= 1920
    template<enum backend B>
#else
    template<enum class backend B>
#endif
    static void* intergen_wrapper_cache() {
        static void* _cached_wrapper=0;
        if (!_cached_wrapper) {
            const coid::token& tok = intergen_default_creator_static(B);
            _cached_wrapper = coid::interface_register::get_interface_creator(tok);
        }
        return _cached_wrapper;
    }

    void* intergen_wrapper( backend bck ) const override final {
        switch(bck) {
        case backend::js:  return intergen_wrapper_cache<backend::js>();
        case backend::jsc: return intergen_wrapper_cache<backend::jsc>();
        case backend::lua: return intergen_wrapper_cache<backend::lua>();
        default: return 0;
        }
    }

    backend intergen_backend() const override { return backend::cxx; }

    const coid::token& intergen_default_creator( backend bck ) const override final {
        return intergen_default_creator_static(bck);
    }

    ///Client registrator
    template<class C>
    static int register_client()
    {
        static_assert(std::is_base_of<pkgview, C>::value, "not a base class");

        typedef intergen_interface* (*fn_client)();
        fn_client cc = []() -> intergen_interface* { return new C; };

        coid::token type = typeid(C).name();
        type.consume("class ");
        type.consume("struct ");

        coid::charstr tmp = "ot::pkgview"_T;
        tmp << "@client-4282493147"_T << '.' << type;

        coid::interface_register::register_interface_creator(tmp, cc);
        return 0;
    }

protected:

    bool set_host(policy_intrusive_base*, intergen_interface*, iref<pkgview>* pout);
};

////////////////////////////////////////////////////////////////////////////////
template<class T>
inline iref<T> pkgview::create( T* _subclass_ )
{
    typedef iref<T> (*fn_creator)(pkgview*);

    static fn_creator create = 0;
    static constexpr coid::token ifckey = "ot::pkgview.create@4282493147"_T;

    if (!create)
        create = reinterpret_cast<fn_creator>(
            coid::interface_register::get_interface_creator(ifckey));

    if (!create) {
        log_mismatch("create"_T, "ot::pkgview.create"_T, "@4282493147"_T);
        return 0;
    }

    return create(_subclass_);
}

#pragma warning(push)
#pragma warning(disable : 4191)

inline void pkgview::set_filter( const coid::token& categories, const coid::token& filter, const coid::token& tags, const coid::token& package, ot::pkginfo::result& res )
{ return VT_CALL(void,(const coid::token&,const coid::token&,const coid::token&,const coid::token&,ot::pkginfo::result&),0)(categories,filter,tags,package,res); }

inline void pkgview::query_range( uint offset, uint count, coid::dynarray32<ot::pkginfo::object_entry>& res ) const
{ return VT_CALL(void,(uint,uint,coid::dynarray32<ot::pkginfo::object_entry>&) const,1)(offset,count,res); }

inline void pkgview::sample_content( const coid::token& url, uint maxcount, coid::dynarray32<ot::pkginfo::object_entry>& res ) const
{ return VT_CALL(void,(const coid::token&,uint,coid::dynarray32<ot::pkginfo::object_entry>&) const,2)(url,maxcount,res); }

inline bool pkgview::get_package( const coid::token& url, coid::charstr& package, coid::charstr& root, bool& skin ) const
{ return VT_CALL(bool,(const coid::token&,coid::charstr&,coid::charstr&,bool&) const,3)(url,package,root,skin); }

inline void pkgview::get_thumbnail_data( const coid::token& url, coid::charstr& thumb_base64 )
{ return VT_CALL(void,(const coid::token&,coid::charstr&),4)(url,thumb_base64); }

#pragma warning(pop)

} //namespace

#endif //_INTERGEN_GENERATED__pkgview_H_
